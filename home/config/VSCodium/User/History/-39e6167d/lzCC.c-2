#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <time.h>

#define DIM 128        // Dimensionality of data
#define N 1000         // Number of data points
#define K 10           // Number of nearest neighbors
#define L 10           // Number of hash tables
#define M 5            // Number of random hyperplanes per hash table

// Data structure for a point
typedef struct {
    float *data;
int id;
} Point;

// Data structure for a hash table bucket
typedef struct Bucket {
    Point *points;
    int size;
    int capacity;
} Bucket;

// Hash table that holds multiple buckets
typedef struct HashTable {
    Bucket *buckets;
    int num_buckets;
} HashTable;

// Function to compute the Euclidean distance between two points
float euclidean_distance(float *p1, float *p2, int dim) {
    float dist = 0.0f;
    for (int i = 0; i < dim; i++) {
        dist += (p1[i] - p2[i]) * (p1[i] - p2[i]);
    }
    return sqrt(dist);
}

// Function to generate a random hyperplane
void generate_random_hyperplane(float *hyperplane, int dim) {
    for (int i = 0; i < dim; i++) {
        hyperplane[i] = ((float) rand() / RAND_MAX) * 2.0f - 1.0f; // Random values between -1 and 1
    }
}

// Function to hash a point using the hyperplane
int hash_point(float *point, float *hyperplane, int dim) {
    float dot_product = 0.0f;
    for (int i = 0; i < dim; i++) {
        dot_product += point[i] * hyperplane[i];
    }
    return (dot_product >= 0) ? 1 : 0; // 1 if the dot product is positive, 0 if negative
}

// Function to create a new bucket
Bucket *create_bucket(int capacity) {
    Bucket *bucket = (Bucket *)malloc(sizeof(Bucket));
    bucket->points = (Point *)malloc(sizeof(Point) * capacity);
    bucket->size = 0;
    bucket->capacity = capacity;
    return bucket;
}

// Function to create a new hash table with L buckets
HashTable *create_hash_table(int num_buckets) {
    HashTable *hash_table = (HashTable *)malloc(sizeof(HashTable));
    hash_table->buckets = (Bucket *)malloc(sizeof(Bucket) * num_buckets);
    hash_table->num_buckets = num_buckets;
    return hash_table;
}

// Function to insert a point into a hash table
void insert_point(HashTable *hash_table, Point *point, int *hash_values) {
    int index = 0;
    for (int i = 0; i < L; i++) {
        index = (index * 2 + hash_values[i]) % hash_table->num_buckets; // Combine hash values to get a bucket index
    }
    Bucket *bucket = &hash_table->buckets[index];
    if (bucket->size >= bucket->capacity) {
        bucket->capacity *= 2;
        bucket->points = (Point *)realloc(bucket->points, sizeof(Point) * bucket->capacity);
    }
    bucket->points[bucket->size++] = *point;
}

// Function to create a new point
Point *create_point(float *data, int id) {
    Point *point = (Point *)malloc(sizeof(Point));
    point->data = data;
    point->id = id;
    return point;
}

// Function to search for nearest neighbors
void search_nearest_neighbors(HashTable *hash_table, float *query, int *hash_values, int k) {
    // Find the relevant hash bucket for the query point
    int index = 0;
    for (int i = 0; i < L; i++) {
        index = (index * 2 + hash_values[i]) % hash_table->num_buckets;
    }

    // Retrieve points from the bucket and find the k-NN
    Bucket *bucket = &hash_table->buckets[index];
    float *distances = (float *)malloc(sizeof(float) * bucket->size);
    for (int i = 0; i < bucket->size; i++) {
        distances[i] = euclidean_distance(query, bucket->points[i].data, DIM);
    }

    // Sort distances and select the k-NN (naive approach for simplicity)
    for (int i = 0; i < bucket->size - 1; i++) {
        for (int j = i + 1; j < bucket->size; j++) {
            if (distances[i] > distances[j]) {
                float temp = distances[i];
                distances[i] = distances[j];
                distances[j] = temp;
            }
        }
    }

    // Print the k-NN
    printf("k-NN for query point:\n");
    for (int i = 0; i < k && i < bucket->size; i++) {
        printf("Neighbor %d: Index = %d, Distance = %f\n", i + 1, bucket->points[i].id, distances[i]);
    }

    free(distances);
}

int main(void) {
    srand(time(NULL));

    // Initialize hash tables for LSH
    HashTable *hash_table = create_hash_table(100);

    // Generate random points and insert them into the hash table
    for (int i = 0; i < N; i++) {
        float *data = (float *)malloc(sizeof(float) * DIM);
        for (int j = 0; j < DIM; j++) {
            data[j] = ((float) rand() / RAND_MAX) * 100.0f;  // Random values between 0 and 100
        }

        // Create a point and generate its hash values
        Point *point = create_point(data, i);
        int *hash_values = (int *)malloc(sizeof(int) * L);
        for (int j = 0; j < L; j++) {
            float *hyperplane = (float *)malloc(sizeof(float) * DIM);
            generate_random_hyperplane(hyperplane, DIM);
            hash_values[j] = hash_point(data, hyperplane, DIM);
            free(hyperplane);
        }

        // Insert the point into the hash table
        insert_point(hash_table, point, hash_values);
        free(hash_values);
    }

    // Perform k-NN search on a random query point
    float *query = (float *)malloc(sizeof(float) * DIM);
    for (int j = 0; j < DIM; j++) {
        query[j] = ((float) rand() / RAND_MAX) * 100.0f;
    }

    int *query_hash_values = (int *)malloc(sizeof(int) * L);
    for (int i = 0; i < L; i++) {
        float *hyperplane = (float *)malloc(sizeof(float) * DIM);
        generate_random_hyperplane(hyperplane, DIM);
        query_hash_values[i] = hash_point(query, hyperplane, DIM);
        free(hyperplane);
    }

    // Search for the nearest neighbors
    search_nearest_neighbors(hash_table, query, query_hash_values, K);

    // Clean up
    free(query);
    free(query_hash_values);
    free(hash_table->buckets);
    free(hash_table);

    return 0;
}
