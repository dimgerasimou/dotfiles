--- st.c
+++ st.c
@@ -1303,115 +1471,126 @@ tmoveto(int x, int y)
 void
 tsetchar(Rune u, const Glyph *attr, int x, int y)
 {
-	static const char *vt100_0[62] = { /* 0x41 - 0x7e */
-		"↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
-		0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
-		0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
-		0, 0, 0, 0, 0, 0, 0, " ", /* X - _ */
-		"◆", "▒", "␉", "␌", "␍", "␊", "°", "±", /* ` - g */
-		"␤", "␋", "┘", "┐", "┌", "└", "┼", "⎺", /* h - o */
-		"⎻", "─", "⎼", "⎽", "├", "┤", "┴", "┬", /* p - w */
-		"│", "≤", "≥", "π", "≠", "£", "·", /* x - ~ */
-	};
+    static const char *vt100_0[62] = { /* 0x41 - 0x7e */
+        "↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
+        0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
+        0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
+        0, 0, 0, 0, 0, 0, 0, " ", /* X - _ */
+        "◆", "▒", "␉", "␌", "␍", "␊", "°", "±", /* ` - g */
+        "␤", "␋", "┘", "┐", "┌", "└", "┼", "⎺", /* h - o */
+        "⎻", "─", "⎼", "⎽", "├", "┤", "┴", "┬", /* p - w */
+        "│", "≤", "≥", "π", "≠", "£", "·", /* x - ~ */
+    };
 
-	/*
-	 * The table is proudly stolen from rxvt.
-	 */
-	if (term.trantbl[term.charset] == CS_GRAPHIC0 &&
-	   BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])
-		utf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);
-
-	if (term.line[y][x].mode & ATTR_WIDE) {
-		if (x+1 < term.col) {
-			term.line[y][x+1].u = ' ';
-			term.line[y][x+1].mode &= ~ATTR_WDUMMY;
-		}
-	} else if (term.line[y][x].mode & ATTR_WDUMMY) {
-		term.line[y][x-1].u = ' ';
-		term.line[y][x-1].mode &= ~ATTR_WIDE;
-	}
+    /*
+     * The table is proudly stolen from rxvt.
+     */
+    if (term.trantbl[term.charset] == CS_GRAPHIC0 &&
+            BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])
+        utf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);
+
+    if (term.line[y][x].mode & ATTR_WIDE) {
+        if (x+1 < term.col) {
+            term.line[y][x+1].u = ' ';
+            term.line[y][x+1].mode &= ~ATTR_WDUMMY;
+        }
+    } else if (term.line[y][x].mode & ATTR_WDUMMY) {
+        term.line[y][x-1].u = ' ';
+        term.line[y][x-1].mode &= ~ATTR_WIDE;
+    }
 
-	term.dirty[y] = 1;
-	term.line[y][x] = *attr;
-	term.line[y][x].u = u;
+    term.dirty[y] = 1;
+    term.line[y][x] = *attr;
+    term.line[y][x].u = u;
+    term.line[y][x].mode |= ATTR_SET;
 }
 
+
+
 void
-tclearregion(int x1, int y1, int x2, int y2)
+tclearglyph(Glyph *gp, int usecurattr)
 {
-	int x, y, temp;
-	Glyph *gp;
+	if (usecurattr) {
+		gp->fg = term.c.attr.fg;
+		gp->bg = term.c.attr.bg;
+	} else {
+		gp->fg = defaultfg;
+		gp->bg = defaultbg;
+	}
+	gp->mode = ATTR_NULL;
+	gp->u = ' ';
+}
 
-	if (x1 > x2)
-		temp = x1, x1 = x2, x2 = temp;
-	if (y1 > y2)
-		temp = y1, y1 = y2, y2 = temp;
 
-	LIMIT(x1, 0, term.col-1);
-	LIMIT(x2, 0, term.col-1);
-	LIMIT(y1, 0, term.row-1);
-	LIMIT(y2, 0, term.row-1);
 
-	for (y = y1; y <= y2; y++) {
+void
+tclearregion(int x1, int y1, int x2, int y2, int usecurattr)
+{
+	int x, y;
+	/* regionselected() takes relative coordinates */
+	if (regionselected(x1+term.scr, y1+term.scr, x2+term.scr, y2+term.scr))
+		selremove();
+
+    for (y = y1; y <= y2; y++) {
 		term.dirty[y] = 1;
-		for (x = x1; x <= x2; x++) {
-			gp = &term.line[y][x];
-			if (selected(x, y))
-				selclear();
-			gp->fg = term.c.attr.fg;
-			gp->bg = term.c.attr.bg;
-			gp->mode = 0;
-			gp->u = ' ';
-		}
+		for (x = x1; x <= x2; x++)
+			tclearglyph(&term.line[y][x], usecurattr);
 	}
 }
 
 void
 tdeletechar(int n)
 {
-	int dst, src, size;
-	Glyph *line;
-
-	LIMIT(n, 0, term.col - term.c.x);
+    int src, dst, size;
+    Line line;
 
-	dst = term.c.x;
-	src = term.c.x + n;
-	size = term.col - src;
-	line = term.line[term.c.y];
+    if (n <= 0)
+        return;
 
-	memmove(&line[dst], &line[src], size * sizeof(Glyph));
-	tclearregion(term.col-n, term.c.y, term.col-1, term.c.y);
+    dst = term.c.x;
+    src = MIN(term.c.x + n, term.col);
+    size = term.col - src;
+    if (size > 0) {
+        /*
+         * otherwise src would point beyond the array
+         * https://stackoverflow.com/questions/29844298
+         */
+        line = term.line[term.c.y];
+        memmove(&line[dst], &line[src], size * sizeof(Glyph));
+    }
+    tclearregion(dst + size, term.c.y, term.col - 1, term.c.y, 1);
 }
 
 void
 tinsertblank(int n)
 {
-	int dst, src, size;
-	Glyph *line;
-
-	LIMIT(n, 0, term.col - term.c.x);
-
-	dst = term.c.x + n;
-	src = term.c.x;
-	size = term.col - dst;
-	line = term.line[term.c.y];
+    int src, dst, size;
+    Line line;
 
-	memmove(&line[dst], &line[src], size * sizeof(Glyph));
-	tclearregion(src, term.c.y, dst - 1, term.c.y);
+    if (n <= 0)
+        return;
+    dst = MIN(term.c.x + n, term.col);
+    src = term.c.x;
+    size = term.col - dst;
+    if (size > 0) { /* otherwise dst would point beyond the array */
+        line = term.line[term.c.y];
+        memmove(&line[dst], &line[src], size * sizeof(Glyph));
+    }
+    tclearregion(src, term.c.y, dst - 1, term.c.y, 1);
 }
 
 void
 tinsertblankline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrolldown(term.c.y, n, 0);
+		tscrolldown(term.c.y, n);
 }
 
 void
 tdeleteline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrollup(term.c.y, n, 0);
+		tscrollup(term.c.y, term.bot, n, SCROLL_NOSAVEHIST);
 }
 
 int32_t
@@ -2659,94 +2839,285 @@ twrite(const char *buf, int buflen, int show_ctrl)
 	return n;
 }
 
+void
+rscrolldown(int n)
+{
+    int i;
+    Line temp;
+
+    /* can never be true as of now
+       if (IS_SET(MODE_ALTSCREEN))
+       return; */
+
+    if ((n = MIN(n, term.histf)) <= 0)
+        return;
+
+    for (i = term.c.y + n; i >= n; i--) {
+        temp = term.line[i];
+        term.line[i] = term.line[i-n];
+        term.line[i-n] = temp;
+    }
+    for (/*i = n - 1 */; i >= 0; i--) {
+        temp = term.line[i];
+        term.line[i] = term.hist[term.histi];
+        term.hist[term.histi] = temp;
+        term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+    }
+    term.c.y += n;
+    term.histf -= n;
+    if ((i = term.scr - n) >= 0) {
+        term.scr = i;
+    } else {
+        term.scr = 0;
+        if (sel.ob.x != -1 && !sel.alt)
+            selmove(-i);
+    }
+}
+
+
+
 void
 tresize(int col, int row)
 {
-	int i, j;
-	int minrow = MIN(row, term.row);
-	int mincol = MIN(col, term.col);
 	int *bp;
-	TCursor c;
 
+	/* col and row are always MAX(_, 1)
 	if (col < 1 || row < 1) {
-		fprintf(stderr,
-		        "tresize: error resizing to %dx%d\n", col, row);
+		fprintf(stderr, "tresize: error resizing to %dx%d\n", col, row);
 		return;
-	}
+	} */
 
-	/*
-	 * slide screen to keep cursor where we expect it -
-	 * tscrollup would work here, but we can optimize to
-	 * memmove because we're freeing the earlier lines
-	 */
-	for (i = 0; i <= term.c.y - row; i++) {
-		free(term.line[i]);
-		free(term.alt[i]);
-	}
-	/* ensure that both src and dst are not NULL */
-	if (i > 0) {
-		memmove(term.line, term.line + i, row * sizeof(Line));
-		memmove(term.alt, term.alt + i, row * sizeof(Line));
-	}
-	for (i += row; i < term.row; i++) {
-		free(term.line[i]);
-		free(term.alt[i]);
-	}
-
-	/* resize to new height */
-	term.line = xrealloc(term.line, row * sizeof(Line));
-	term.alt  = xrealloc(term.alt,  row * sizeof(Line));
 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
+ 	if (col > term.col) {
+ 		bp = term.tabs + term.col;
+ 		memset(bp, 0, sizeof(*term.tabs) * (col - term.col));
+ 		while (--bp > term.tabs && !*bp)
+ 			/* nothing */ ;
+ 		for (bp += tabspaces; bp < term.tabs + col; bp += tabspaces)
+ 			*bp = 1;
+ 	}
 
-	for (i = 0; i < HISTSIZE; i++) {
-		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
-		for (j = mincol; j < col; j++) {
-			term.hist[i][j] = term.c.attr;
-			term.hist[i][j].u = ' ';
-		}
-	}
+	if (IS_SET(MODE_ALTSCREEN))
+		tresizealt(col, row);
+	else
+		tresizedef(col, row);
+}
 
-	/* resize each row to new width, zero-pad if needed */
-	for (i = 0; i < minrow; i++) {
-		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
-		term.alt[i]  = xrealloc(term.alt[i],  col * sizeof(Glyph));
-	}
 
-	/* allocate any new rows */
-	for (/* i = minrow */; i < row; i++) {
-		term.line[i] = xmalloc(col * sizeof(Glyph));
-		term.alt[i] = xmalloc(col * sizeof(Glyph));
+void
+tresizedef(int col, int row)
+{
+	int i, j;
+
+	/* return if dimensions haven't changed */
+	if (term.col == col && term.row == row) {
+		tfulldirt();
+		return;
 	}
-	if (col > term.col) {
-		bp = term.tabs + term.col;
-
-		memset(bp, 0, sizeof(*term.tabs) * (col - term.col));
-		while (--bp > term.tabs && !*bp)
-			/* nothing */ ;
-		for (bp += tabspaces; bp < term.tabs + col; bp += tabspaces)
-			*bp = 1;
+	if (col != term.col) {
+		if (!sel.alt)
+			selremove();
+		treflow(col, row);
+	} else {
+		/* slide screen up if otherwise cursor would get out of the screen */
+		if (term.c.y >= row) {
+			tscrollup(0, term.row - 1, term.c.y - row + 1, SCROLL_RESIZE);
+			term.c.y = row - 1;
+ 		}
+		for (i = row; i < term.row; i++)
+			free(term.line[i]);
+
+		/* resize to new height */
+		term.line = xrealloc(term.line, row * sizeof(Line));
+		/* allocate any new rows */
+		for (i = term.row; i < row; i++) {
+			term.line[i] = xmalloc(col * sizeof(Glyph));
+			for (j = 0; j < col; j++)
+				tclearglyph(&term.line[i][j], 0);
+ 		}
+		/* scroll down as much as height has increased */
+		rscrolldown(row - term.row);
 	}
 	/* update terminal size */
-	term.col = col;
-	term.row = row;
+	term.col = col, term.row = row;
 	/* reset scrolling region */
-	tsetscroll(0, row-1);
-	/* make use of the LIMIT in tmoveto */
-	tmoveto(term.c.x, term.c.y);
-	/* Clearing both screens (it makes dirty all lines) */
-	c = term.c;
-	for (i = 0; i < 2; i++) {
-		if (mincol < col && 0 < minrow) {
-			tclearregion(mincol, 0, col - 1, minrow - 1);
-		}
-		if (0 < col && minrow < row) {
-			tclearregion(0, minrow, col - 1, row - 1);
-		}
-		tswapscreen();
-		tcursor(CURSOR_LOAD);
-	}
-	term.c = c;
+	term.top = 0, term.bot = row - 1;
+	/* dirty all lines */
+	tfulldirt();
+}
+
+
+
+void
+tresizealt(int col, int row)
+{
+    int i, j;
+
+    /* return if dimensions haven't changed */
+    if (term.col == col && term.row == row) {
+        tfulldirt();
+        return;
+    }
+    if (sel.alt)
+        selremove();
+    /* slide screen up if otherwise cursor would get out of the screen */
+    for (i = 0; i <= term.c.y - row; i++)
+        free(term.line[i]);
+    if (i > 0) {
+        /* ensure that both src and dst are not NULL */
+        memmove(term.line, term.line + i, row * sizeof(Line));
+        term.c.y = row - 1;
+    }
+    for (i += row; i < term.row; i++)
+        free(term.line[i]);
+    /* resize to new height */
+    term.line = xrealloc(term.line, row * sizeof(Line));
+    /* resize to new width */
+    for (i = 0; i < MIN(row, term.row); i++) {
+        term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
+        for (j = term.col; j < col; j++)
+            tclearglyph(&term.line[i][j], 0);
+    }
+    /* allocate any new rows */
+    for (/*i = MIN(row, term.row) */; i < row; i++) {
+        term.line[i] = xmalloc(col * sizeof(Glyph));
+        for (j = 0; j < col; j++)
+            tclearglyph(&term.line[i][j], 0);
+    }
+    /* update cursor */
+    if (term.c.x >= col) {
+        term.c.state &= ~CURSOR_WRAPNEXT;
+        term.c.x = col - 1;
+    } else {
+        UPDATEWRAPNEXT(1, col);
+    }
+    /* update terminal size */
+    term.col = col, term.row = row;
+    /* reset scrolling region */
+    term.top = 0, term.bot = row - 1;
+    /* dirty all lines */
+    tfulldirt();
+ }
+
+
+
+
+
+void
+treflow(int col, int row)
+{
+    int i, j;
+    int oce, nce, bot, scr;
+    int ox = 0, oy = -term.histf, nx = 0, ny = -1, len;
+    int cy = -1; /* proxy for new y coordinate of cursor */
+    int nlines;
+    Line *buf, line;
+
+    /* y coordinate of cursor line end */
+    for (oce = term.c.y; oce < term.row - 1 &&
+            tiswrapped(term.line[oce]); oce++);
+
+    nlines = term.histf + oce + 1;
+    if (col < term.col) {
+        /* each line can take this many lines after reflow */
+        j = (term.col + col - 1) / col;
+        nlines = j * nlines;
+        if (nlines > HISTSIZE + RESIZEBUFFER + row) {
+            nlines = HISTSIZE + RESIZEBUFFER + row;
+            oy = -(nlines / j - oce - 1);
+        }
+    }
+    buf = xmalloc(nlines * sizeof(Line));
+    do {
+        if (!nx)
+            buf[++ny] = xmalloc(col * sizeof(Glyph));
+        if (!ox) {
+            line = TLINEABS(oy);
+            len = tlinelen(line);
+        }
+        if (oy == term.c.y) {
+            if (!ox)
+                len = MAX(len, term.c.x + 1);
+            /* update cursor */
+            if (cy < 0 && term.c.x - ox < col - nx) {
+                term.c.x = nx + term.c.x - ox, cy = ny;
+                UPDATEWRAPNEXT(0, col);
+            }
+        }
+        /* get reflowed lines in buf */
+        if (col - nx > len - ox) {
+            memcpy(&buf[ny][nx], &line[ox], (len-ox) * sizeof(Glyph));
+            nx += len - ox;
+            if (len == 0 || !(line[len - 1].mode & ATTR_WRAP)) {
+                for (j = nx; j < col; j++)
+                    tclearglyph(&buf[ny][j], 0);
+                nx = 0;
+            } else if (nx > 0) {
+                buf[ny][nx - 1].mode &= ~ATTR_WRAP;
+            }
+            ox = 0, oy++;
+        } else if (col - nx == len - ox) {
+            memcpy(&buf[ny][nx], &line[ox], (col-nx) * sizeof(Glyph));
+            ox = 0, oy++, nx = 0;
+        } else/* if (col - nx < len - ox) */ {
+            memcpy(&buf[ny][nx], &line[ox], (col-nx) * sizeof(Glyph));
+            ox += col - nx;
+            buf[ny][col - 1].mode |= ATTR_WRAP;
+            nx = 0;
+        }
+    } while (oy <= oce);
+    if (nx)
+        for (j = nx; j < col; j++)
+            tclearglyph(&buf[ny][j], 0);
+
+    /* free extra lines */
+    for (i = row; i < term.row; i++)
+        free(term.line[i]);
+    /* resize to new height */
+    term.line = xrealloc(term.line, row * sizeof(Line));
+
+    bot = MIN(ny, row - 1);
+    scr = MAX(row - term.row, 0);
+    /* update y coordinate of cursor line end */
+    nce = MIN(oce + scr, bot);
+    /* update cursor y coordinate */
+    term.c.y = nce - (ny - cy);
+    if (term.c.y < 0) {
+        j = nce, nce = MIN(nce + -term.c.y, bot);
+        term.c.y += nce - j;
+        while (term.c.y < 0) {
+            free(buf[ny--]);
+            term.c.y++;
+        }
+    }
+    /* allocate new rows */
+    for (i = row - 1; i > nce; i--) {
+        term.line[i] = xmalloc(col * sizeof(Glyph));
+        for (j = 0; j < col; j++)
+            tclearglyph(&term.line[i][j], 0);
+    }
+    /* fill visible area */
+    for (/*i = nce */; i >= term.row; i--, ny--)
+        term.line[i] = buf[ny];
+    for (/*i = term.row - 1 */; i >= 0; i--, ny--) {
+        free(term.line[i]);
+        term.line[i] = buf[ny];
+    }
+    /* fill lines in history buffer and update term.histf */
+    for (/*i = -1 */; ny >= 0 && i >= -HISTSIZE; i--, ny--) {
+        j = (term.histi + i + 1 + HISTSIZE) % HISTSIZE;
+        free(term.hist[j]);
+        term.hist[j] = buf[ny];
+    }
+    term.histf = -i - 1;
+    term.scr = MIN(term.scr, term.histf);
+    /* resize rest of the history lines */
+    for (/*i = -term.histf - 1 */; i >= -HISTSIZE; i--) {
+        j = (term.histi + i + 1 + HISTSIZE) % HISTSIZE;
+        term.hist[j] = xrealloc(term.hist[j], col * sizeof(Glyph));
+    }
+    free(buf);
 }
 
 void
@@ -2786,9 +3157,8 @@ draw(void)
 		cx--;
 
 	drawregion(0, 0, term.col, term.row);
-	if (term.scr == 0)
-		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
-				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
 	term.ocx = cx;
 	term.ocy = term.c.y;
 	xfinishdraw();
